# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kGRDHQX4ia_zyE0u7eOjyImy6f_kBG3O

**Классифицировать положительные и отрицательные данные о пневмонии из коллекции рентгеновских изображений.**

Пневмония – это инфекция, которая воспаляет воздушные мешки в одном или обоих легких. Воздушные мешки наполняются жидкостью или гноем, вызывая кашель с мокротой или гноем, лихорадку, озноб и затрудненное дыхание. Бактерии, вирусы, грибки могут вызывать пневмонию.
Степень тяжести пневмонии может варьироваться от легкой до опасной для жизни. Пневмония  наиболее опасно для младенцев и маленьких детей, людей старше 65 лет, а так же для людей со слабым иммунитетом.

Цель: разработка автоматизированного анализа рентгеновских снимков грудной клетки на основе искусственного интеллекта для обнаружения пневмонии, продемонстрировать что ИИ может отличить пациентов с пневмонией от здоровых.
"""

# Commented out IPython magic to ensure Python compatibility.
from tensorflow.keras import  applications  #Приложение
from tensorflow.keras.preprocessing.image import ImageDataGenerator #Работа с изображениями
from tensorflow.keras.models import  Sequential  #Сеть прямого распростронения
from tensorflow.keras.layers import Dropout, Flatten, Dense, GlobalAveragePooling2D #Слои для сверточных сетей
from tensorflow.keras.layers import Conv2D, MaxPooling2D #Слои для сыерточных сетей
from tensorflow.keras.models import Model
from tensorflow.keras.models import load_model
from tensorflow.keras.optimizers import Adam #Оптимизатор
from tensorflow.keras.preprocessing import image #Длоя отрисовки изображения
from google.colab import files #Для загрузки свих картинок
import os #Для работы с файлами
from glob import  glob
import numpy as np #Библиотека работы с массивами
import matplotlib.pyplot as plt #Для отрисовки графиков
from PIL import  Image #Для отрисовки изображения
import math #Для округления
# %matplotlib inline

from google.colab import drive  #Подключаем диск
drive.mount('/content/drive')

"""Для анализа рентгеновских снимков грудной клетки все рентгенограммы грудной клетки первоначально были проверены на предмет контроля качества, удалены все снимки не читаемые  и некачественные. Диагнозы для изображений были затем оценены врачами-экспертами, прежде чем быть допущенными к обучению искусственным интеллектом.

Набор данных расположен в трех папках (train, test, val) и содержит под папки для каждой категории (Пневмония/Норма) в формате JPEG. 
"""

train_path = '/content/drive/MyDrive/chest_xray'   #Путь к папки с даннми изображениями. Распаковываем каталог chest_xray на папки train, test, val каждая папка содержит рентгеновские снимки которые понадабятся для обучения и тестирования
batch_size = 10  #Размер выборки
img_hight = 139  #Высота изображения
img_width = 139  #Ширина изображения
epochs = 50
train_samples = 1000
validatrion_samples = 100
dirs = os.listdir(train_path)
print(dirs)

#Устанавливаем путь к каждой папки
train_folder = train_path + '/train/'
test_folder = train_path + '/test/'
val_folder = train_path + '/val/'

train_dirs = os.listdir(train_folder)
print(train_dirs)

#Берем учебную папку и указываем путь к каждому классу
train_normal = train_folder + 'NORMAL/'
train_pneu = train_folder + 'PNEUMONIA/'

#После разделения учебной папкаи на "NORMAL" и "PNEUMONIA" мы можем извлеяь изображения из каждого класса ( изображения находятся в формате jpeg)
pneu_images = glob(train_pneu + '*.jpeg')
normal_images = glob(train_normal + '*.jpeg')

#Функция визуализирует нам изображения из тренировочного набора, покажим нормальныеизображения и с пневмонией, цветнаякарта для изображений серого цвета.
def show_images(num_of_imgs):

  for img in range(num_of_imgs):
    pneu_pic = np.asarray(plt.imread(pneu_images[img]))
    normal_pic = np.asarray(plt.imread(normal_images[img]))

    fig = plt.figure(figsize=(15, 10))

    normal_plot = fig.add_subplot(1, 2, 1)
    plt.imshow(normal_pic, cmap='gray')
    normal_plot.set_title('Normal')

    pneu_plot = fig.add_subplot(1, 2, 2)
    plt.imshow(pneu_pic, cmap='gray')
    pneu_plot.set_title('Pneumonia')
    plt.axis('off')

    plt.show()

show_images(3)

#Предворительная обработка изображений и увеличение данных  с сипользованием ImageDataGenerator 
datagen = ImageDataGenerator(
    rescale=1./255,          #Значение цвета меняем на дробные показатели
    shear_range=0.2,         #Угол сдвига
    zoom_range=0.2,          #Зумируем изображение
    rotation_range=0.2,      #Поворачиваем изображение
    width_shift_range=0.2,   #Двигаем изображение по ширине
    height_shift_range=0.2,  #Двигаем изображение по высоте
    horizontal_flip=True     #Отключаем отзеркаливание изображения
)

#Масштобируем тестовый набор
test_datagen = ImageDataGenerator(
    rescale=1./255)

#Взьмем путь к папкам тестирование , обучение, проверка и сгенерируем пакеты дополнительных данных
train_generator = datagen.flow_from_directory(train_folder, target_size=(img_width, img_hight), batch_size=batch_size, class_mode='binary')
validation_generator = test_datagen.flow_from_directory(val_folder, target_size=(img_width, img_hight), batch_size=batch_size, class_mode='binary')
test_generator = test_datagen.flow_from_directory(test_folder, target_size=(img_width, img_hight), batch_size=batch_size, class_mode='binary')

model = Sequential()

model.add(Conv2D(256, (3, 3), padding='same', activation='relu', input_shape=(img_width, img_hight, 3)))

model.add(Conv2D(256, (3, 3), padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(3, 3)))

model.add(Conv2D(256, (3, 3), padding='same', activation='relu'))

model.add(Dropout(0.2))

model.add(Conv2D(256, (3, 3), padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(3, 3)))

model.add(Dropout(0.2))

model.add(Conv2D(512, (3, 3), padding='same', activation='relu'))

model.add(Conv2D(1024, (3, 3), padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(3, 3)))

model.add(Dropout(0.2))

model.add(Flatten())

model.add(Dense(2048, activation='relu'))

model.add(Dense(4096, activation='relu'))

model.add(Dense(len(train_generator.class_indices), activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer=Adam(lr=0.00001), metrics=['accuracy'])

model.summary()

history = model.fit_generator(
    train_generator,
    steps_per_epoch = train_generator.samples // batch_size,
    validation_data = validation_generator, 
    validation_steps = validation_generator.samples // batch_size,
    epochs=epochs, verbose=1)

history = model.fit_generator(
    train_generator,
    steps_per_epoch = train_samples // batch_size,
    validation_data = validation_generator, 
    validation_steps = validatrion_samples // batch_size,
    epochs=epochs)

model = Sequential()

model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(img_width, img_hight, 3), padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(32, (3, 3), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())
model.add(Dense(128, activation = 'relu'))
model.add(Dropout(0.5))
model.add(Dense(len(train_generator.class_indices), activation = 'sigmoid'))

model.compile(loss='categorical_crossentropy', optimizer=Adam(lr=0.0001), metrics=['accuracy'])

history = model.fit_generator(
    train_generator,
    steps_per_epoch = train_samples // batch_size,
    validation_data = validation_generator, 
    validation_steps = validatrion_samples // batch_size,
    epochs=epochs)

from tensorflow.kerasons.inception_v3 import  InceptionV3.applicati #Сверточная нейронная от google, сеть сосотоящая из 48 слоёв

model_ac = applications.InceptionV3(weights='imagenet', include_top=False, input_shape=(img_width, img_hight, 3))

ust_model = Sequential()
ust_model.add(GlobalAveragePooling2D(input_shape=model_ac.output_shape[1:], data_format=None))
ust_model.add(Dense(256, activation='relu'))
ust_model.add(Dropout(0.5))
ust_model.add(Dense(1, activation='sigmoid'))

model = Model(inputs=model_ac.input, outputs=ust_model(model_ac.output))

#Структура модели
model.summary()

#Компелируем модель
model.compile(optimizer=Adam(lr=0.0001, beta_1=0.9), loss='binary_crossentropy', metrics=['accuracy'])

from tensorflow.keras.utils import plot_model

#Схема модели
plot_model(model, to_file='model.png')

#Обучаем сеть
history = model.fit_generator(
    train_generator, 
    steps_per_epoch= train_samples // batch_size,
    epochs= epochs,
    validation_data= validation_generator,
    validation_steps= validatrion_samples // batch_size)

model.save('model')

#Оцениваем точность модели
test_accuracy = model.evaluate_generator(test_generator, steps=624)

print('Testing Accuracy: {:.2f}%'.format(test_accuracy[1] * 100))

#Отобразим график точности обучения
plt.plot(history.history['accuracy'],
         label='Доля верных ответов на обучающем наборе')
plt.plot(history.history['val_accuracy'],
         label='Доля верных ответов на проверочном наборе')
plt.xlabel('Эпоха обучения')
plt.ylabel('Доля верных ответов')
plt.legend()
plt.show()

model = load_model('model')

"""Рассмотрим как наша модель справится с загруженными снимками.

Врач загружает в систему изображение. Дальше система покажет есть ли у пациента заболевание или нет. Это позволит оперативно провести дообследование, что значительно экономит время мед персонала, который вынужден работать  сегодня с большим объёмом информации.

"""

#Проводим проверку по распознованию заболевания
prov = '/content/drive/MyDrive/chest_xray/test/PNEUMONIA/person100_bacteria_478.jpeg'

prov_1 = image.load_img(prov, target_size=(img_width, img_hight))

plt.imshow(prov_1)
plt.show()

prov_1 = image.img_to_array(prov_1)

x = np.expand_dims(prov_1, axis=0)* 1./255

score = model.predict(x)

print('Резудьтат: ', score, 'Вы здоровы' if score < 0.5 else 'Вы нездоровы, пожалуйста обратитесь к врачу')